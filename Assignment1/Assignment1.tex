\documentclass[12pt]{article}
\usepackage[a4paper]{geometry}
\usepackage[myheadings]{fullpage}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{graphicx}
\usepackage[T1]{fontenc}
\usepackage[font=small, labelfont=bf]{caption}
\usepackage{fourier}
\usepackage[protrusion=true, expansion=true]{microtype}
\usepackage[english]{babel}
\usepackage{sectsty}
\usepackage{url, lipsum}
\usepackage{tgbonum}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{textcomp}
\usepackage{datetime}

\newcommand\tab[1][1cm]{\hspace*{#1}}
\newcommand{\HRule}[1]{\rule{\linewidth}{#1}}
\setcounter{tocdepth}{5}
\setcounter{secnumdepth}{5}

\pagestyle{fancy}
\fancyhf{} 
\fancyhead[L]{Group 5}
\fancyhead[C]{CP431 - A1}
\fancyhead[R]{01.30.23}
\fancyfoot[C]{\thepage}

\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=C,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\begin{document} {
    % ------------- COVER PAGE -------------
    \fontfamily{put}\selectfont
    \title
    { 
        \normalsize \textsc{}
        \\ [2.0cm]
        \HRule{3pt} \\
        \LARGE \textbf
        {
            {
                CP431 - Parallel Programming \\
                Assignment \#1 \\
            }
            \HRule{3pt} \\ [0.5cm]
            \textbf{\LARGE{Topic: MPI Programming For Gaps Between Prime Numbers}}
        }
    }
    
    \author {
    	Aidan Traboulay, Memet Rusidovski, \\
        Mobina Tooranisama, Nausher Rao, Zamil Bahri \\ \\
    	Group 5
	}
    
    \date {
        \textbf{\today}
    }
    
    \maketitle
    % ------------- INTRO --------------
    \newpage
    \section {Introduction}
    This report presents a comprehensive evaluation of the performance and runtime of three (3) parallel implementations of a program that calculates prime gaps up to a trillion $(10^{12})$. The prime gap is defined as the difference between two consecutive prime numbers and plays a crucial role in several mathematical and computational problems. The report focuses on the comparison of the runtime and scalability of the three implementations and provides insights into their strengths and weaknesses through benchmarking. Additionally, the report highlights the challenges faced during the parallelization process and discusses potential solutions for improving the performance of the program. 
    
    % ------------- IMPLEMENTATION --------------
    \newpage
    \section {Implementation}
    \subsection{Using GMP Library}
    \begin{lstlisting}
#include <stdio.h>
#include <stdlib.h>
#include <mpi.h>
#include <gmp.h>
#include <math.h>
#include <assert.h>

#define MAX(A, B) (A > B ? A : B)
#define MIN(A, B) (A < B ? A : B)
#define MAX_PRIME 100000000 // 10^8 (100 million)

/* Prototypes */
void print_mpz(char tag[], mpz_t n, char end[]);

/* Print Function */
void print_mpz(char tag[], mpz_t n, char end[]) {
	printf("%s = ", tag);
	mpz_out_str(stdout, 10, n);
	printf("%s", end);
}

/* Main Function */
int main(int argc, char** argv) {
	// Initialize the MPI environment
	int rank, size;

	// Initialize mpz_t variables
	mpz_t N;
	int flag_N;
	mpz_init(N);
	mpz_set_ui(N,MAX_PRIME);

	// Declare timer variables
	double first_time, second_time, duration, global_duration;

	// Declare prime variables
	int flag;
	mpz_t start, end, gap, prime, prev, load;

	// Initialize above mpz_t variables and set initial values
	mpz_init(start);
	mpz_init(end);
	mpz_init(gap);
	mpz_init(prime);
	mpz_init(prev);
	mpz_init(load);

	mpz_set_ui(start,0);
	mpz_set_ui(end,0);
	mpz_set_ui(gap,0);
	mpz_set_ui(prime,2);
	mpz_set_ui(prev,2);
	mpz_set_ui(load,0);

	MPI_Init(&argc, &argv);
	MPI_Comm_size(MPI_COMM_WORLD, &size);
	MPI_Comm_rank(MPI_COMM_WORLD, &rank);

	// Declare the start and end values of process
	mpz_div_ui(load, N, size);
	mpz_mul_ui(start, load, rank);
	mpz_add(end, start, load);

	// Store largest gap and the prime associated with it & first and last primes in this process
	mpz_t local_primegap[2]; 
	mpz_t first_last_primes[2]; 
	unsigned long local_primegap_ui[2];
	unsigned long first_last_primes_ui[2];

	// Find the first prime in this process to initialize first_last_primes[]
	mpz_nextprime(prime, start);
	mpz_set(prev, prime);

	// mpz_init() above arrays
	for (int i = 0; i < 2; ++i) {
		mpz_init(local_primegap[i]);
		mpz_init(first_last_primes[i]);
	}

	mpz_set(local_primegap[0], gap);
	mpz_set(local_primegap[1], prime);

	mpz_set(first_last_primes[0], prime);

	// Start timer
	first_time = MPI_Wtime();

	while (1) {
		mpz_nextprime(prime, prime);

		// Break loop if prime > end. Record the last prime encountered
		if (mpz_cmp(prime, end) > 0) {
			mpz_set(first_last_primes[1], prev);
			break;
		}

		// Calculate the gap between current and previous prime
		mpz_sub(gap, prime, prev);

		// Ff this is the largest gap, then record it and the associated prime
		if (mpz_cmp(gap, local_primegap[0]) >= 0) {
			mpz_set(local_primegap[0], gap);
			mpz_set(local_primegap[1], prime);
		}

		// Update previous prime to currrent prime
		mpz_set(prev, prime);
	}

	// End timer
	second_time = MPI_Wtime();
	duration = second_time - first_time;
	printf("rank = %d, local duration = %lf\n", rank, duration);

	// Send first and last primes to root thread
	first_last_primes_ui[0] = mpz_get_ui(first_last_primes[0]);
	first_last_primes_ui[1] = mpz_get_ui(first_last_primes[1]);

	if (rank != 0) {
		MPI_Send(first_last_primes_ui, 2, MPI_UNSIGNED_LONG, 0, 1, MPI_COMM_WORLD);
	}

	// Get the local largest gap and associated prime in the form of unsigned long
	local_primegap_ui[0] = mpz_get_ui(local_primegap[0]);
	local_primegap_ui[1] = mpz_get_ui(local_primegap[1]);

	// Find the max of all the local largest gaps
	unsigned long global_primegap[2];
	MPI_Reduce(local_primegap_ui, global_primegap, 2, MPI_UNSIGNED_LONG, MPI_MAX, 0, MPI_COMM_WORLD);

	// Find the max of time taken by any thread
	MPI_Reduce(&duration, &global_duration, 1, MPI_DOUBLE, MPI_MAX, 0, MPI_COMM_WORLD);

	// Find the gaps between first primes of a process and last primes of the preceding process
	if (rank == 0) {
		// Declare array to store first and last primes from all processes
		unsigned long all_first_last_primes[size*2];

		// Store the first and last primes from root process
		all_first_last_primes[0] = first_last_primes_ui[0];
		all_first_last_primes[1] = first_last_primes_ui[1];

		// Receive first and last primes from other processes and store them
		MPI_Status status;
		for (int i = 1; i < size; ++i) {
			MPI_Recv(first_last_primes_ui, 2, MPI_UNSIGNED_LONG, i, 1, MPI_COMM_WORLD, &status);
			all_first_last_primes[i*2] = first_last_primes_ui[0];
			all_first_last_primes[i*2+1] = first_last_primes_ui[1];
		}

		// Find the difference between consecutive elements (ignore first and last elements).
		// If diff > largest gap, then recognize it
		unsigned long diff;
		for (int i = 2; i < size*2-1; i+=2) {
			diff =  all_first_last_primes[i] - all_first_last_primes[i-1];
			if (diff > global_primegap[0]) {
				global_primegap[0] = diff;
				global_primegap[1] = all_first_last_primes[i];
			}
		}

		// Output the largest gap and the associated prime
		printf("max gap = %lu, between %lu and %lu\n", global_primegap[0], global_primegap[1]-global_primegap[0], global_primegap[1]);
		printf("global runtime is %f\n", global_duration);
	}

	// End MPI Program
	MPI_Finalize();

	return 0;
}
    \end{lstlisting}
    \subsection{Without GMP Library}
    \begin{lstlisting}
    \end{lstlisting}

    \subsection{Serial Version (Non-Parallel)}
    \begin{lstlisting}
#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include <math.h>
#include <mpi.h>
#include <stdlib.h>

int segmentedSieve(int n, int first_primes[], int count, int start);

int SieveOfEratosthenes(int n, int lst[])
{
    float sqt = sqrt(n);
    int flr = floor(sqt) + 1;

    bool prime[flr + 1];
    memset(prime, true, sizeof(prime));

    int x = 0;
    int c = 0;

    for (int p = 2; p * p <= flr; p++)
    {
        if (prime[p] == true)
        {
            for (int i = p * p; i <= flr; i += p) {
                prime[i] = false;
            }
        }
        x++;
    }

    for (int p = 2; p <= flr; p++)
        if (prime[p]) {
            lst[c] = p;
            c++;
        }

    return c;
}

int main()
{
    int n = 100000000;
    int largest_gap = 0;
    int G = 0;

    float sqt = sqrt(n);
    int flr = floor(sqt) + 1;
    
    printf("This is the biggest gap from one to %d \n", n);
    int x[flr+1];

    memset(x, 0, sizeof x);

    int count = SieveOfEratosthenes(n, x);

    int block_size = 10000;
    for (int i = block_size; i < n; i += block_size){
    if (i > n == false)
        G = segmentedSieve(block_size + i - 1, x, count, i);

        if (G > largest_gap)
        {
            largest_gap = G;
            G = 0;
        }
    }
    printf("%d", largest_gap);

    return 0;
}

int segmentedSieve(int n, int first_primes[], int count, int start)
{
    float sqt = sqrt(n);
    int flr = floor(sqt) + 1;

    int limit = start;

    int gap = 0;
    int max_gap = 0;
    // a block of the primes all set to true ex [100..200]
    bool block[n - start + 1];//limit + 1];
    memset(block, true, sizeof(block));

    int low = limit;
    int high = 2 * limit;
    int c = 0;

    while (low < n)
    {
        if (high >= n)
            high = n;
        c++;

        for (int i = 0; i < count; i++)
        {
            float temp = ((float)low) / ((float)first_primes[i]);
            int lowest_lim = floor(temp) * first_primes[i];

            if (lowest_lim < low)
            lowest_lim += first_primes[i];

            for (int j = lowest_lim; j < high; j += first_primes[i])
            block[j - low] = false;
        }

        for (int i = low; i < high; i++)
        {
            if (block[i - low] == true){
                if (max_gap < gap)
                    max_gap = gap;
                    gap = 0;
            }
            gap++;
        }

        low = low + limit;
        high = high + limit;
    }

    return max_gap;
}
    \end{lstlisting}
    
     % ------------- BENCHMARKS --------------
    \newpage
    \section {Benchmarks}
    \subsection{Using GMP Library}
    % ------------- ANALYSIS --------------
    \newpage 
    \section {Analysis}
    
    % ------------- REFERENCES --------------
    \newpage
    \section {References}
    
\end{document}